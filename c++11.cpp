#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <iomanip>
#include <string>
// 新增：Windows平台下引入头文件，用于设置控制台编码
#ifdef _WIN32
#include <windows.h>
#endif

using namespace std;

class Complex {
private:
    double real;  // 实部
    double imag;  // 虚部

public:
    // 构造函数
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 获取实部
    double getReal() const { return real; }
    // 获取虚部
    double getImag() const { return imag; }
    // 设置实部
    void setReal(double r) { real = r; }
    // 设置虚部
    void setImag(double i) { imag = i; }

    // 计算复数的模
    double modulus() const { return sqrt(real * real + imag * imag); }

    // 重载相等运算符（实部和虚部均相同才判定相等）
    bool operator==(const Complex& other) const {
        return (real == other.real) && (imag == other.imag);
    }

    // 重载不等运算符
    bool operator!=(const Complex& other) const {
        return !(*this == other);
    }

    // 重载输出运算符，自定义复数打印格式
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << fixed << setprecision(2);  // 保留2位小数
        if (c.imag >= 0) {
            os << c.real << " + " << c.imag << "i";
        } else {
            os << c.real << " - " << -c.imag << "i";
        }
        return os;
    }
};

// 生成单个随机复数（实部和虚部在[minVal, maxVal]范围内）
Complex generateRandomComplex(double minVal, double maxVal) {
    double real = minVal + (rand() % 1000) / 1000.0 * (maxVal - minVal);
    double imag = minVal + (rand() % 1000) / 1000.0 * (maxVal - minVal);
    return Complex(real, imag);
}

// 生成随机复数向量
vector<Complex> generateRandomComplexVector(int size, double minVal, double maxVal) {
    vector<Complex> vec;
    for (int i = 0; i < size; ++i) {
        vec.push_back(generateRandomComplex(minVal, maxVal));
    }
    return vec;
}

// 向量置乱（Fisher-Yates 洗牌算法）
void shuffleVector(vector<Complex>& vec) {
    for (int i = vec.size() - 1; i > 0; --i) {
        int j = rand() % (i + 1);  // 生成[0, i]的随机索引
        swap(vec[i], vec[j]);      // 交换元素
    }
}

// 查找元素（返回目标元素的索引，未找到返回-1）
int findElement(const vector<Complex>& vec, const Complex& target) {
    for (size_t i = 0; i < vec.size(); ++i) {  // size_t匹配vector.size()的无符号类型
        if (vec[i] == target) {
            return static_cast<int>(i);  // 显式转换为int返回
        }
    }
    return -1;
}

// 插入元素（在指定位置pos插入元素elem）
void insertElement(vector<Complex>& vec, size_t pos, const Complex& elem) {
    if (pos <= vec.size()) {  // 无符号数无需判断>=0，pos最大为向量长度（插入到末尾）
        vec.insert(vec.begin() + pos, elem);
    }
}

// 删除元素（删除指定位置pos的元素，成功返回true，失败返回false）
bool deleteElement(vector<Complex>& vec, size_t pos) {
    if (pos < vec.size()) {
        vec.erase(vec.begin() + pos);
        return true;
    }
    return false;
}

// 向量唯一化（去除重复元素）
void uniqueVector(vector<Complex>& vec) {
    vector<Complex> temp;
    for (size_t i = 0; i < vec.size(); ++i) {
        const Complex& elem = vec[i];
        bool isDuplicate = false;
        // 检查当前元素是否已在temp中
        for (size_t j = 0; j < temp.size(); ++j) {
            if (elem == temp[j]) {
                isDuplicate = true;
                break;
            }
        }
        if (!isDuplicate) {
            temp.push_back(elem);
        }
    }
    vec = temp;  // 用去重后的temp替换原向量
}

// 起泡排序（按模升序，模相同按实部升序）
void bubbleSort(vector<Complex>& vec) {
    size_t n = vec.size();
    for (size_t i = 0; i < n - 1; ++i) {
        // 每轮冒泡后，最大元素沉到末尾，下一轮无需检查
        for (size_t j = 0; j < n - i - 1; ++j) {
            double modJ = vec[j].modulus();
            double modJ1 = vec[j + 1].modulus();
            // 比较规则：先比模，模相同比实部
            if (modJ > modJ1 || (modJ == modJ1 && vec[j].getReal() > vec[j + 1].getReal())) {
                swap(vec[j], vec[j + 1]);
            }
        }
    }
}

// 归并排序辅助函数（合并左右两个有序子数组）
void merge(vector<Complex>& vec, int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子数组长度
    int n2 = right - mid;     // 右子数组长度

    // 临时存储左右子数组
    vector<Complex> leftVec(n1), rightVec(n2);
    for (int i = 0; i < n1; ++i) {
        leftVec[i] = vec[left + i];
    }
    for (int j = 0; j < n2; ++j) {
        rightVec[j] = vec[mid + 1 + j];
    }

    // 合并临时数组到原数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        double modL = leftVec[i].modulus();
        double modR = rightVec[j].modulus();
        if (modL < modR || (modL == modR && leftVec[i].getReal() <= rightVec[j].getReal())) {
            vec[k] = leftVec[i];
            i++;
        } else {
            vec[k] = rightVec[j];
            j++;
        }
        k++;
    }

    // 处理剩余元素
    while (i < n1) {
        vec[k] = leftVec[i];
        i++;
        k++;
    }
    while (j < n2) {
        vec[k] = rightVec[j];
        j++;
        k++;
    }
}

// 归并排序（递归实现，按模升序，模相同按实部升序）
void mergeSort(vector<Complex>& vec, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;  // 避免溢出（替代(left+right)/2）
        mergeSort(vec, left, mid);            // 排序左子数组
        mergeSort(vec, mid + 1, right);       // 排序右子数组
        merge(vec, left, mid, right);         // 合并两个有序子数组
    }
}

// 区间查找（查找模介于[m1, m2)的元素，返回子向量）
vector<Complex> rangeSearch(const vector<Complex>& vec, double m1, double m2) {
    vector<Complex> result;
    for (size_t i = 0; i < vec.size(); ++i) {
        const Complex& elem = vec[i];
        double mod = elem.modulus();
        if (mod >= m1 && mod < m2) {
            result.push_back(elem);
        }
    }
    return result;
}

// 打印向量（带自定义提示信息）
void printVector(const vector<Complex>& vec, const string& msg = "") {
    if (!msg.empty()) {
        cout << msg << endl;
    }
    // 遍历向量打印每个元素及模
    for (size_t i = 0; i < vec.size(); ++i) {
        const Complex& elem = vec[i];
        cout << elem << " (模: " << fixed << setprecision(2) << elem.modulus() << ")\t";
        // 每5个元素换行（避免一行过长）
        if ((i + 1) % 5 == 0) {
            cout << endl;
        }
    }
    cout << endl << endl;  // 末尾空两行，区分不同步骤的输出
}

int main() {
    // 新增：设置Windows控制台编码为GBK，解决中文乱码
    #ifdef _WIN32
    SetConsoleOutputCP(936);
    #endif

    srand(time(0));  // 初始化随机数种子（确保每次运行随机结果不同）

    // ---------------------- 测试1：向量基本操作（置乱、查找、插入、删除、唯一化） ----------------------
    int basicSize = 10;
    // 生成初始随机复数向量
    vector<Complex> complexVec = generateRandomComplexVector(basicSize, -10, 10);
    printVector(complexVec, "1. 初始随机复数向量（10个元素）:");

    // 置乱向量
    shuffleVector(complexVec);
    printVector(complexVec, "2. 置乱后的向量:");

    // 查找随机元素
    if (!complexVec.empty()) {
        size_t randPos = rand() % complexVec.size();
        Complex target = complexVec[randPos];
        int findRes = findElement(complexVec, target);
        if (findRes != -1) {
            cout << "3. 查找结果：元素 " << target << " 的索引位置为 " << findRes << endl << endl;
        } else {
            cout << "3. 查找结果：未找到元素 " << target << endl << endl;
        }
    }

    // 插入元素（在索引2位置插入(100, 200)）
    Complex insertElem(100, 200);
    insertElement(complexVec, 2, insertElem);
    printVector(complexVec, "4. 在索引2插入元素 " + to_string(insertElem.getReal()) + " + " + to_string(insertElem.getImag()) + "i 后的向量:");

    // 删除元素（删除索引2位置的元素）
    if (deleteElement(complexVec, 2)) {
        printVector(complexVec, "5. 删除索引2的元素后的向量:");
    } else {
        cout << "5. 删除失败：索引2超出向量范围" << endl << endl;
    }

    // 向量唯一化
    uniqueVector(complexVec);
    printVector(complexVec, "6. 唯一化后的向量（去除重复元素）:");

    // ---------------------- 测试2：排序效率对比（起泡排序 vs 归并排序） ----------------------
    int sortTestSize = 1000;  // 排序测试的向量大小（可调整，越大差异越明显）
    vector<Complex> randomVec = generateRandomComplexVector(sortTestSize, -100, 100);  // 随机向量
    vector<Complex> sortedVec = randomVec;
    mergeSort(sortedVec, 0, static_cast<int>(sortedVec.size()) - 1);  // 有序向量（用归并排序提前排好）
    vector<Complex> reversedVec = sortedVec;
    reverse(reversedVec.begin(), reversedVec.end());  // 逆序向量

    clock_t start, end;
    double duration;
    cout << "---------------------- 排序效率测试（向量大小：" << sortTestSize << "） ----------------------" << endl;

    // 1. 随机顺序下的排序效率
    // 起泡排序（随机）
    vector<Complex> bubbleRandom = randomVec;
    start = clock();
    bubbleSort(bubbleRandom);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "1. 随机顺序：" << endl;
    cout << "   起泡排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl;

    // 归并排序（随机）
    vector<Complex> mergeRandom = randomVec;
    start = clock();
    mergeSort(mergeRandom, 0, static_cast<int>(mergeRandom.size()) - 1);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "   归并排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl << endl;

    // 2. 有序顺序下的排序效率
    // 起泡排序（有序）
    vector<Complex> bubbleSorted = sortedVec;
    start = clock();
    bubbleSort(bubbleSorted);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "2. 有序顺序：" << endl;
    cout << "   起泡排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl;

    // 归并排序（有序）
    vector<Complex> mergeSorted = sortedVec;
    start = clock();
    mergeSort(mergeSorted, 0, static_cast<int>(mergeSorted.size()) - 1);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "   归并排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl << endl;

    // 3. 逆序顺序下的排序效率
    // 起泡排序（逆序）
    vector<Complex> bubbleReversed = reversedVec;
    start = clock();
    bubbleSort(bubbleReversed);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "3. 逆序顺序：" << endl;
    cout << "   起泡排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl;

    // 归并排序（逆序）
    vector<Complex> mergeReversed = reversedVec;
    start = clock();
    mergeSort(mergeReversed, 0, static_cast<int>(mergeReversed.size()) - 1);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "   归并排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl << endl;

    // ---------------------- 测试3：区间查找 ----------------------
    double m1 = 5.0, m2 = 10.0;  // 查找模介于[5.0, 10.0)的元素
    vector<Complex> rangeRes = rangeSearch(sortedVec, m1, m2);
    if (rangeRes.empty()) {
        cout << "---------------------- 区间查找结果 ----------------------" << endl;
        cout << "模介于[" << m1 << ", " << m2 << ")的元素不存在" << endl << endl;
    } else {
        printVector(rangeRes, "---------------------- 区间查找结果 ----------------------\n模介于[" + to_string(m1) + ", " + to_string(m2) + ")的元素（共" + to_string(rangeRes.size()) + "个）:");
    }

    // 新增：暂停窗口，避免执行完直接关闭（需手动按任意键退出）
    system("pause");

    return 0;
}