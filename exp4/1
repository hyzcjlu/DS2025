#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <algorithm>
#include <cmath>
#include <iomanip>
#include <functional>  // 新增：std::function所需头文件
#include <utility>     // 新增：std::pair所需头文件

using namespace std;
using namespace chrono;

// 边界框结构体：包含位置、大小、置信度、索引（排序后保留原始索引）
struct BBox {
    float x1, y1, x2, y2; // 左上角、右下角坐标
    float score;          // 置信度
    int idx;              // 原始索引
    BBox(float x1_ = 0, float y1_ = 0, float x2_ = 0, float y2_ = 0, float s_ = 0, int i_ = 0)
        : x1(x1_), y1(y1_), x2(x2_), y2(y2_), score(s_), idx(i_) {}
};

// ====================== 排序算法实现 ======================
// 1. 快速排序（按置信度降序）
template <typename T>
int partition(vector<T>& arr, int low, int high) {
    float pivot = arr[high].score;
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (arr[j].score >= pivot) { // 降序排序
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[high]);
    return i + 1;
}

template <typename T>
void quickSort(vector<T>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// 2. 归并排序（按置信度降序）
template <typename T>
void merge(vector<T>& arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;
    vector<T> L(n1), R(n2);
    
    for (int i = 0; i < n1; i++) L[i] = arr[l + i];
    for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
    
    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i].score >= R[j].score) { // 降序
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i < n1) { arr[k] = L[i]; i++; k++; }
    while (j < n2) { arr[k] = R[j]; j++; k++; }
}

template <typename T>
void mergeSort(vector<T>& arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

// 3. 堆排序（按置信度降序）
template <typename T>
void heapify(vector<T>& arr, int n, int i) {
    int largest = i;
    int l = 2 * i + 1;
    int r = 2 * i + 2;
    
    if (l < n && arr[l].score > arr[largest].score) largest = l;
    if (r < n && arr[r].score > arr[largest].score) largest = r;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

template <typename T>
void heapSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

// 4. 冒泡排序（按置信度降序）
template <typename T>
void bubbleSort(vector<T>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j].score < arr[j+1].score) { // 降序
                swap(arr[j], arr[j+1]);
            }
        }
    }
}

// ====================== NMS算法实现 ======================
// 计算IoU（交并比）
float calculateIoU(const BBox& a, const BBox& b) {
    float interX1 = max(a.x1, b.x1);
    float interY1 = max(a.y1, b.y1);
    float interX2 = min(a.x2, b.x2);
    float interY2 = min(a.y2, b.y2);
    
    float interArea = max(0.0f, interX2 - interX1) * max(0.0f, interY2 - interY1);
    float areaA = (a.x2 - a.x1) * (a.y2 - a.y1);
    float areaB = (b.x2 - b.x1) * (b.y2 - b.y1);
    float unionArea = areaA + areaB - interArea;
    
    return unionArea == 0 ? 0 : interArea / unionArea;
}

// 基础NMS算法（输入排序后的边界框，IoU阈值默认0.5）
vector<BBox> NMS(vector<BBox> bboxes, float iouThresh = 0.5) {
    vector<BBox> result;
    if (bboxes.empty()) return result;
    
    while (!bboxes.empty()) {
        // 取置信度最高的框
        BBox top = bboxes[0];
        result.push_back(top);
        
        // 移除当前框，过滤IoU超过阈值的框
        vector<BBox> remaining;
        for (size_t i = 1; i < bboxes.size(); i++) {
            if (calculateIoU(top, bboxes[i]) < iouThresh) {
                remaining.push_back(bboxes[i]);
            }
        }
        bboxes = remaining;
    }
    return result;
}

// ====================== 数据生成函数 ======================
// 生成随机分布的边界框
vector<BBox> generateRandomBBoxes(int num, float imgW = 640, float imgH = 640) {
    vector<BBox> bboxes;
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> coordDist(0, min(imgW, imgH)); // 坐标范围
    uniform_real_distribution<float> sizeDist(10, 100);             // 宽高范围
    uniform_real_distribution<float> scoreDist(0, 1);               // 置信度范围
    
    for (int i = 0; i < num; i++) {
        float x1 = coordDist(gen);
        float y1 = coordDist(gen);
        float w = sizeDist(gen);
        float h = sizeDist(gen);
        float x2 = min(x1 + w, imgW);
        float y2 = min(y1 + h, imgH);
        float score = scoreDist(gen);
        bboxes.emplace_back(x1, y1, x2, y2, score, i);
    }
    return bboxes;
}

// 生成聚集分布的边界框（围绕多个中心点聚集）
vector<BBox> generateClusteredBBoxes(int num, int clusterNum = 5, float imgW = 640, float imgH = 640) {
    vector<BBox> bboxes;
    random_device rd;
    mt19937 gen(rd());
    uniform_real_distribution<float> centerDist(50, imgW-50); // 聚集中心坐标
    uniform_real_distribution<float> offsetDist(-30, 30);     // 偏移量（聚集）
    uniform_real_distribution<float> sizeDist(10, 100);       // 宽高范围
    uniform_real_distribution<float> scoreDist(0, 1);         // 置信度范围
    
    // 生成聚集中心
    vector<pair<float, float>> centers;
    for (int i = 0; i < clusterNum; i++) {
        centers.emplace_back(centerDist(gen), centerDist(gen));
    }
    
    for (int i = 0; i < num; i++) {
        // 随机选一个聚集中心
        auto& center = centers[gen() % clusterNum];
        float x1 = center.first + offsetDist(gen);
        float y1 = center.second + offsetDist(gen);
        x1 = max(0.0f, min(x1, imgW));
        y1 = max(0.0f, min(y1, imgH));
        
        float w = sizeDist(gen);
        float h = sizeDist(gen);
        float x2 = min(x1 + w, imgW);
        float y2 = min(y1 + h, imgH);
        float score = scoreDist(gen);
        bboxes.emplace_back(x1, y1, x2, y2, score, i);
    }
    return bboxes;
}

// ====================== 性能测试函数 ======================
// 测试单个排序算法在NMS中的耗时（堆排序/冒泡排序）
double testSortInNMS(vector<BBox> bboxes, void (*sortFunc)(vector<BBox>&)) {
    // 拷贝数据（避免原数据被修改）
    vector<BBox> bboxesCopy = bboxes;
    
    // 记录排序+NMS总耗时
    auto start = high_resolution_clock::now();
    
    // 1. 排序
    sortFunc(bboxesCopy);
    // 2. NMS
    NMS(bboxesCopy);
    
    auto end = high_resolution_clock::now();
    duration<double, milli> duration = end - start;
    return duration.count(); // 返回毫秒数
}

// 测试快速排序/归并排序（需传入l/r参数）
double testQuickMergeSortInNMS(vector<BBox> bboxes, void (*sortFunc)(vector<BBox>&, int, int)) {
    vector<BBox> bboxesCopy = bboxes;
    auto start = high_resolution_clock::now();
    
    sortFunc(bboxesCopy, 0, (int)bboxesCopy.size()-1);
    NMS(bboxesCopy);
    
    auto end = high_resolution_clock::now();
    duration<double, milli> duration = end - start;
    return duration.count();
}

// 批量测试不同排序算法、不同数据规模/分布的性能
void batchTest() {
    // 测试配置
    vector<int> scales = {100, 500, 1000, 2000, 5000, 10000}; // 数据规模
    vector<string> distributions = {"随机分布", "聚集分布"};
    
    // 输出表头
    cout << left << setw(10) << "数据规模" << setw(10) << "数据分布";
    cout << setw(15) << "快速排序(ms)" << setw(15) << "归并排序(ms)";
    cout << setw(15) << "堆排序(ms)" << setw(15) << "冒泡排序(ms)" << endl;
    cout << string(80, '-') << endl;
    
    // 遍历所有配置测试
    for (int scale : scales) {
        for (string& dist : distributions) {
            // 生成对应分布的数据集
            vector<BBox> bboxes;
            if (dist == "随机分布") {
                bboxes = generateRandomBBoxes(scale);
            } else {
                bboxes = generateClusteredBBoxes(scale);
            }
            
            // 拷贝不同数据集（避免排序修改原数据）
            vector<BBox> b1 = bboxes, b2 = bboxes, b3 = bboxes, b4 = bboxes;
            
            // 测试各排序算法
            double t_quick = testQuickMergeSortInNMS(b1, quickSort);
            double t_merge = testQuickMergeSortInNMS(b2, mergeSort);
            double t_heap = testSortInNMS(b3, heapSort);
            double t_bubble = testSortInNMS(b4, bubbleSort);
            
            // 输出结果
            cout << left << setw(10) << scale << setw(10) << dist;
            cout << setw(15) << fixed << setprecision(2) << t_quick;
            cout << setw(15) << fixed << setprecision(2) << t_merge;
            cout << setw(15) << fixed << setprecision(2) << t_heap;
            cout << setw(15) << fixed << setprecision(2) << t_bubble << endl;
        }
    }
}

// ====================== 主函数 ======================
int main() {
    cout << "===== 排序算法在NMS中的性能测试 =====" << endl;
    batchTest();
    
    // NMS时间复杂度理论分析输出
    cout << "\n===== NMS算法时间复杂度理论分析 =====" << endl;
    cout << "1. 排序阶段：占主导地位，时间复杂度由排序算法决定：" << endl;
    cout << "   - 快速/归并/堆排序：O(n log n)" << endl;
    cout << "   - 冒泡排序：O(n²)" << endl;
    cout << "2. NMS阶段：最坏情况下O(n²)（每个框都需对比），实际约O(n)" << endl;
    cout << "3. 总时间复杂度：排序主导，快速/归并/堆排序为O(n log n)，冒泡为O(n²)" << endl;
    
    return 0;
}
