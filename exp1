任务1
#include <iostream>
#include <vector>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <iomanip>
#include <string>
// 新增：Windows平台下引入头文件，用于设置控制台编码
#ifdef _WIN32
#include <windows.h>
#endif

using namespace std;

class Complex {
private:
    double real;  // 实部
    double imag;  // 虚部

public:
    // 构造函数
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 获取实部
    double getReal() const { return real; }
    // 获取虚部
    double getImag() const { return imag; }
    // 设置实部
    void setReal(double r) { real = r; }
    // 设置虚部
    void setImag(double i) { imag = i; }

    // 计算复数的模
    double modulus() const { return sqrt(real * real + imag * imag); }

    // 重载相等运算符（实部和虚部均相同才判定相等）
    bool operator==(const Complex& other) const {
        return (real == other.real) && (imag == other.imag);
    }

    // 重载不等运算符
    bool operator!=(const Complex& other) const {
        return !(*this == other);
    }

    // 重载输出运算符，自定义复数打印格式
    friend ostream& operator<<(ostream& os, const Complex& c) {
        os << fixed << setprecision(2);  // 保留2位小数
        if (c.imag >= 0) {
            os << c.real << " + " << c.imag << "i";
        } else {
            os << c.real << " - " << -c.imag << "i";
        }
        return os;
    }
};

// 生成单个随机复数（实部和虚部在[minVal, maxVal]范围内）
Complex generateRandomComplex(double minVal, double maxVal) {
    double real = minVal + (rand() % 1000) / 1000.0 * (maxVal - minVal);
    double imag = minVal + (rand() % 1000) / 1000.0 * (maxVal - minVal);
    return Complex(real, imag);
}

// 生成随机复数向量
vector<Complex> generateRandomComplexVector(int size, double minVal, double maxVal) {
    vector<Complex> vec;
    for (int i = 0; i < size; ++i) {
        vec.push_back(generateRandomComplex(minVal, maxVal));
    }
    return vec;
}

// 向量置乱（Fisher-Yates 洗牌算法）
void shuffleVector(vector<Complex>& vec) {
    for (int i = vec.size() - 1; i > 0; --i) {
        int j = rand() % (i + 1);  // 生成[0, i]的随机索引
        swap(vec[i], vec[j]);      // 交换元素
    }
}

// 查找元素（返回目标元素的索引，未找到返回-1）
int findElement(const vector<Complex>& vec, const Complex& target) {
    for (size_t i = 0; i < vec.size(); ++i) {  // size_t匹配vector.size()的无符号类型
        if (vec[i] == target) {
            return static_cast<int>(i);  // 显式转换为int返回
        }
    }
    return -1;
}

// 插入元素（在指定位置pos插入元素elem）
void insertElement(vector<Complex>& vec, size_t pos, const Complex& elem) {
    if (pos <= vec.size()) {  // 无符号数无需判断>=0，pos最大为向量长度（插入到末尾）
        vec.insert(vec.begin() + pos, elem);
    }
}

// 删除元素（删除指定位置pos的元素，成功返回true，失败返回false）
bool deleteElement(vector<Complex>& vec, size_t pos) {
    if (pos < vec.size()) {
        vec.erase(vec.begin() + pos);
        return true;
    }
    return false;
}

// 向量唯一化（去除重复元素）
void uniqueVector(vector<Complex>& vec) {
    vector<Complex> temp;
    for (size_t i = 0; i < vec.size(); ++i) {
        const Complex& elem = vec[i];
        bool isDuplicate = false;
        // 检查当前元素是否已在temp中
        for (size_t j = 0; j < temp.size(); ++j) {
            if (elem == temp[j]) {
                isDuplicate = true;
                break;
            }
        }
        if (!isDuplicate) {
            temp.push_back(elem);
        }
    }
    vec = temp;  // 用去重后的temp替换原向量
}

// 起泡排序（按模升序，模相同按实部升序）
void bubbleSort(vector<Complex>& vec) {
    size_t n = vec.size();
    for (size_t i = 0; i < n - 1; ++i) {
        // 每轮冒泡后，最大元素沉到末尾，下一轮无需检查
        for (size_t j = 0; j < n - i - 1; ++j) {
            double modJ = vec[j].modulus();
            double modJ1 = vec[j + 1].modulus();
            // 比较规则：先比模，模相同比实部
            if (modJ > modJ1 || (modJ == modJ1 && vec[j].getReal() > vec[j + 1].getReal())) {
                swap(vec[j], vec[j + 1]);
            }
        }
    }
}

// 归并排序辅助函数（合并左右两个有序子数组）
void merge(vector<Complex>& vec, int left, int mid, int right) {
    int n1 = mid - left + 1;  // 左子数组长度
    int n2 = right - mid;     // 右子数组长度

    // 临时存储左右子数组
    vector<Complex> leftVec(n1), rightVec(n2);
    for (int i = 0; i < n1; ++i) {
        leftVec[i] = vec[left + i];
    }
    for (int j = 0; j < n2; ++j) {
        rightVec[j] = vec[mid + 1 + j];
    }

    // 合并临时数组到原数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        double modL = leftVec[i].modulus();
        double modR = rightVec[j].modulus();
        if (modL < modR || (modL == modR && leftVec[i].getReal() <= rightVec[j].getReal())) {
            vec[k] = leftVec[i];
            i++;
        } else {
            vec[k] = rightVec[j];
            j++;
        }
        k++;
    }

    // 处理剩余元素
    while (i < n1) {
        vec[k] = leftVec[i];
        i++;
        k++;
    }
    while (j < n2) {
        vec[k] = rightVec[j];
        j++;
        k++;
    }
}

// 归并排序（递归实现，按模升序，模相同按实部升序）
void mergeSort(vector<Complex>& vec, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;  // 避免溢出（替代(left+right)/2）
        mergeSort(vec, left, mid);            // 排序左子数组
        mergeSort(vec, mid + 1, right);       // 排序右子数组
        merge(vec, left, mid, right);         // 合并两个有序子数组
    }
}

// 区间查找（查找模介于[m1, m2)的元素，返回子向量）
vector<Complex> rangeSearch(const vector<Complex>& vec, double m1, double m2) {
    vector<Complex> result;
    for (size_t i = 0; i < vec.size(); ++i) {
        const Complex& elem = vec[i];
        double mod = elem.modulus();
        if (mod >= m1 && mod < m2) {
            result.push_back(elem);
        }
    }
    return result;
}

// 打印向量（带自定义提示信息）
void printVector(const vector<Complex>& vec, const string& msg = "") {
    if (!msg.empty()) {
        cout << msg << endl;
    }
    // 遍历向量打印每个元素及模
    for (size_t i = 0; i < vec.size(); ++i) {
        const Complex& elem = vec[i];
        cout << elem << " (模: " << fixed << setprecision(2) << elem.modulus() << ")\t";
        // 每5个元素换行（避免一行过长）
        if ((i + 1) % 5 == 0) {
            cout << endl;
        }
    }
    cout << endl << endl;  // 末尾空两行，区分不同步骤的输出
}

int main() {
    // 新增：设置Windows控制台编码为GBK，解决中文乱码
    #ifdef _WIN32
    SetConsoleOutputCP(936);
    #endif

    srand(time(0));  // 初始化随机数种子（确保每次运行随机结果不同）

    // ---------------------- 测试1：向量基本操作（置乱、查找、插入、删除、唯一化） ----------------------
    int basicSize = 10;
    // 生成初始随机复数向量
    vector<Complex> complexVec = generateRandomComplexVector(basicSize, -10, 10);
    printVector(complexVec, "1. 初始随机复数向量（10个元素）:");

    // 置乱向量
    shuffleVector(complexVec);
    printVector(complexVec, "2. 置乱后的向量:");

    // 查找随机元素
    if (!complexVec.empty()) {
        size_t randPos = rand() % complexVec.size();
        Complex target = complexVec[randPos];
        int findRes = findElement(complexVec, target);
        if (findRes != -1) {
            cout << "3. 查找结果：元素 " << target << " 的索引位置为 " << findRes << endl << endl;
        } else {
            cout << "3. 查找结果：未找到元素 " << target << endl << endl;
        }
    }

    // 插入元素（在索引2位置插入(100, 200)）
    Complex insertElem(100, 200);
    insertElement(complexVec, 2, insertElem);
    printVector(complexVec, "4. 在索引2插入元素 " + to_string(insertElem.getReal()) + " + " + to_string(insertElem.getImag()) + "i 后的向量:");

    // 删除元素（删除索引2位置的元素）
    if (deleteElement(complexVec, 2)) {
        printVector(complexVec, "5. 删除索引2的元素后的向量:");
    } else {
        cout << "5. 删除失败：索引2超出向量范围" << endl << endl;
    }

    // 向量唯一化
    uniqueVector(complexVec);
    printVector(complexVec, "6. 唯一化后的向量（去除重复元素）:");

    // ---------------------- 测试2：排序效率对比（起泡排序 vs 归并排序） ----------------------
    int sortTestSize = 1000;  // 排序测试的向量大小（可调整，越大差异越明显）
    vector<Complex> randomVec = generateRandomComplexVector(sortTestSize, -100, 100);  // 随机向量
    vector<Complex> sortedVec = randomVec;
    mergeSort(sortedVec, 0, static_cast<int>(sortedVec.size()) - 1);  // 有序向量（用归并排序提前排好）
    vector<Complex> reversedVec = sortedVec;
    reverse(reversedVec.begin(), reversedVec.end());  // 逆序向量

    clock_t start, end;
    double duration;
    cout << "---------------------- 排序效率测试（向量大小：" << sortTestSize << "） ----------------------" << endl;

    // 1. 随机顺序下的排序效率
    // 起泡排序（随机）
    vector<Complex> bubbleRandom = randomVec;
    start = clock();
    bubbleSort(bubbleRandom);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "1. 随机顺序：" << endl;
    cout << "   起泡排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl;

    // 归并排序（随机）
    vector<Complex> mergeRandom = randomVec;
    start = clock();
    mergeSort(mergeRandom, 0, static_cast<int>(mergeRandom.size()) - 1);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "   归并排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl << endl;

    // 2. 有序顺序下的排序效率
    // 起泡排序（有序）
    vector<Complex> bubbleSorted = sortedVec;
    start = clock();
    bubbleSort(bubbleSorted);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "2. 有序顺序：" << endl;
    cout << "   起泡排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl;

    // 归并排序（有序）
    vector<Complex> mergeSorted = sortedVec;
    start = clock();
    mergeSort(mergeSorted, 0, static_cast<int>(mergeSorted.size()) - 1);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "   归并排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl << endl;

    // 3. 逆序顺序下的排序效率
    // 起泡排序（逆序）
    vector<Complex> bubbleReversed = reversedVec;
    start = clock();
    bubbleSort(bubbleReversed);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "3. 逆序顺序：" << endl;
    cout << "   起泡排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl;

    // 归并排序（逆序）
    vector<Complex> mergeReversed = reversedVec;
    start = clock();
    mergeSort(mergeReversed, 0, static_cast<int>(mergeReversed.size()) - 1);
    end = clock();
    duration = (double)(end - start) / CLOCKS_PER_SEC;
    cout << "   归并排序耗时：" << fixed << setprecision(6) << duration << " 秒" << endl << endl;

    // ---------------------- 测试3：区间查找 ----------------------
    double m1 = 5.0, m2 = 10.0;  // 查找模介于[5.0, 10.0)的元素
    vector<Complex> rangeRes = rangeSearch(sortedVec, m1, m2);
    if (rangeRes.empty()) {
        cout << "---------------------- 区间查找结果 ----------------------" << endl;
        cout << "模介于[" << m1 << ", " << m2 << ")的元素不存在" << endl << endl;
    } else {
        printVector(rangeRes, "---------------------- 区间查找结果 ----------------------\n模介于[" + to_string(m1) + ", " + to_string(m2) + ")的元素（共" + to_string(rangeRes.size()) + "个）:");
    }

    // 新增：暂停窗口，避免执行完直接关闭（需手动按任意键退出）
    system("pause");

    return 0;
}


任务2
#include <iostream>
#include <cstring>
#include <cmath>
#include <cctype>
using namespace std;

#ifdef _WIN32
#include <windows.h>
#endif

// 运算符枚举
enum Optr {
    ADD, SUB, MUL, DIV, POW, FACT, L_P, R_P, EOE, 
    SIN, COS, TAN, LOG, LN
};

// 栈模板类
template <typename T>
class Stack {
private:
    T data[100];
    int top;
public:
    Stack() : top(-1) {}
    bool isEmpty() const { return top == -1; }
    bool isFull() const { return top == 99; }
    void push(T elem) { if (!isFull()) data[++top] = elem; }
    T pop() { return (top >= 0) ? data[top--] : T(); }
    T getTop() const { return (top >= 0) ? data[top] : T(); }
};

// 运算符优先级表
const char pri[14][14] = {
    //       +     -     *     /     ^     !     (     )    \0   SIN   COS   TAN   LOG   LN
    /* + */  '>',  '>',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* - */  '>',  '>',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<', 
    /* * */  '>',  '>',  '>',  '>',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* / */  '>',  '>',  '>',  '>',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* ^ */  '>',  '>',  '>',  '>',  '>',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* ! */  '>',  '>',  '>',  '>',  '>',  '>',  ' ',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* ( */  '<',  '<',  '<',  '<',  '<',  '<',  '<',  '=',  ' ',  '<',  '<',  '<',  '<',  '<',
    /* ) */  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',  ' ',
    /* \0*/  '<',  '<',  '<',  '<',  '<',  '<',  '<',  ' ',  '=',  '<',  '<',  '<',  '<',  '<',
    /* SIN*/ '<',  '<',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* COS*/ '<',  '<',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* TAN*/ '<',  '<',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* LOG*/ '<',  '<',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<',
    /* LN */ '<',  '<',  '<',  '<',  '<',  '<',  '<',  '>',  '>',  '<',  '<',  '<',  '<',  '<'
};

// 字符转运算符
Optr charToOptr(const char* expr, int& i) {
    // 跳过空格
    while (expr[i] == ' ') i++;
    
    if (expr[i] == '\0') return EOE;

    // 单字符运算符
    switch (expr[i]) {
        case '+': i++; return ADD;
        case '-': i++; return SUB;
        case '*': i++; return MUL;
        case '/': i++; return DIV;
        case '^': i++; return POW;
        case '!': i++; return FACT;
        case '(': i++; return L_P;
        case ')': i++; return R_P;
    }

    // 多字符函数
    if (strncmp(&expr[i], "sin", 3) == 0 || strncmp(&expr[i], "SIN", 3) == 0) {
        i += 3;
        return SIN;
    }
    if (strncmp(&expr[i], "cos", 3) == 0 || strncmp(&expr[i], "COS", 3) == 0) {
        i += 3;
        return COS;
    }
    if (strncmp(&expr[i], "tan", 3) == 0 || strncmp(&expr[i], "TAN", 3) == 0) {
        i += 3;
        return TAN;
    }
    if (strncmp(&expr[i], "log", 3) == 0 || strncmp(&expr[i], "LOG", 3) == 0) {
        i += 3;
        return LOG;
    }
    if (strncmp(&expr[i], "ln", 2) == 0 || strncmp(&expr[i], "LN", 2) == 0) {
        i += 2;
        return LN;
    }

    return EOE;
}

// 计算函数
double calculate(Optr op, double a, double b = 0) {
    switch (op) {
        case ADD: return a + b;
        case SUB: return a - b;
        case MUL: return a * b;
        case DIV: 
            if (b == 0) {
                cerr << "Error: Division by zero!" << endl;
                return 0;
            }
            return a / b;
        case POW: return pow(a, b);
        case FACT: {
            int n = static_cast<int>(a);
            if (n < 0 || a != n) {
                cerr << "Error: Factorial requires non-negative integer!" << endl;
                return 0;
            }
            double res = 1;
            for (int i = 1; i <= n; ++i) res *= i;
            return res;
        }
        case SIN: return sin(a);
        case COS: return cos(a);
        case TAN: return tan(a);
        case LOG: 
            if (a <= 0) {
                cerr << "Error: log argument must be positive!" << endl;
                return 0;
            }
            return log10(a);
        case LN:  
            if (a <= 0) {
                cerr << "Error: ln argument must be positive!" << endl;
                return 0;
            }
            return log(a);
        default: return 0;
    }
}

// 解析并计算表达式
double evaluate(const char* expr) {
    Stack<double> numStack;
    Stack<Optr> optrStack;
    optrStack.push(EOE);
    
    int i = 0;
    int len = strlen(expr);
    bool expectOperand = true;

    while (i < len || !optrStack.isEmpty()) {
        // 跳过空格
        while (i < len && expr[i] == ' ') i++;
        
        if (i >= len) {
            // 表达式结束，处理剩余运算符
            while (!optrStack.isEmpty() && optrStack.getTop() != EOE) {
                Optr op = optrStack.pop();
                if (op == SIN || op == COS || op == TAN || op == LOG || op == LN) {
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operand for function!" << endl;
                        return 0;
                    }
                    double a = numStack.pop();
                    numStack.push(calculate(op, a));
                } else if (op == FACT) {
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operand for factorial!" << endl;
                        return 0;
                    }
                    double a = numStack.pop();
                    numStack.push(calculate(op, a));
                } else {
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operands!" << endl;
                        return 0;
                    }
                    double b = numStack.pop();
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operands!" << endl;
                        return 0;
                    }
                    double a = numStack.pop();
                    numStack.push(calculate(op, a, b));
                }
            }
            break;
        }

        char c = expr[i];
        
        // 解析数字
        if (isdigit(c) || c == '.') {
            double num = 0.0;
            bool hasDecimal = false;
            double decimalFactor = 0.1;

            // 整数部分
            while (i < len && isdigit(expr[i])) {
                num = num * 10 + (expr[i] - '0');
                i++;
            }

            // 小数部分
            if (i < len && expr[i] == '.') {
                hasDecimal = true;
                i++;
                while (i < len && isdigit(expr[i])) {
                    num += (expr[i] - '0') * decimalFactor;
                    decimalFactor *= 0.1;
                    i++;
                }
            }

            numStack.push(num);
            expectOperand = false;
        }
        // 处理运算符和函数
        else {
            int old_i = i;
            Optr currOp = charToOptr(expr, i);
            
            if (currOp == EOE && old_i == i) {
                // 无法识别的字符
                cerr << "Error: Unrecognized character '" << expr[i] << "'" << endl;
                i++;
                continue;
            }

            // 处理负号（作为一元运算符）
            if (currOp == SUB && expectOperand) {
                // 处理一元负号：压入0，然后进行减法
                numStack.push(0);
                optrStack.push(SUB);
                expectOperand = true;
                continue;
            }

            if (currOp == R_P) {
                // 处理右括号：计算直到遇到左括号
                while (!optrStack.isEmpty() && optrStack.getTop() != L_P) {
                    Optr op = optrStack.pop();
                    if (op == SIN || op == COS || op == TAN || op == LOG || op == LN) {
                        if (numStack.isEmpty()) {
                            cerr << "Error: Missing operand for function!" << endl;
                            return 0;
                        }
                        double a = numStack.pop();
                        numStack.push(calculate(op, a));
                    } else if (op == FACT) {
                        if (numStack.isEmpty()) {
                            cerr << "Error: Missing operand for factorial!" << endl;
                            return 0;
                        }
                        double a = numStack.pop();
                        numStack.push(calculate(op, a));
                    } else {
                        if (numStack.isEmpty()) {
                            cerr << "Error: Missing operands!" << endl;
                            return 0;
                        }
                        double b = numStack.pop();
                        if (numStack.isEmpty()) {
                            cerr << "Error: Missing operands!" << endl;
                            return 0;
                        }
                        double a = numStack.pop();
                        numStack.push(calculate(op, a, b));
                    }
                }
                if (optrStack.isEmpty() || optrStack.getTop() != L_P) {
                    cerr << "Error: Mismatched parentheses!" << endl;
                    return 0;
                }
                optrStack.pop(); // 弹出左括号
                expectOperand = false;
                continue;
            }

            Optr topOp = optrStack.getTop();
            
            // 检查优先级表
            if (topOp < 0 || topOp > 13 || currOp < 0 || currOp > 13) {
                cerr << "Error: Invalid operator!" << endl;
                return 0;
            }
            
            char priority = pri[topOp][currOp];

            if (priority == '<') {
                optrStack.push(currOp);
                expectOperand = true;
            }
            else if (priority == '=') {
                optrStack.pop();
                expectOperand = false;
            }
            else if (priority == '>') {
                optrStack.pop();
                
                if (topOp == SIN || topOp == COS || topOp == TAN || topOp == LOG || topOp == LN) {
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operand for function!" << endl;
                        return 0;
                    }
                    double a = numStack.pop();
                    numStack.push(calculate(topOp, a));
                }
                else if (topOp == FACT) {
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operand for factorial!" << endl;
                        return 0;
                    }
                    double a = numStack.pop();
                    numStack.push(calculate(topOp, a));
                }
                else {
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operands!" << endl;
                        return 0;
                    }
                    double b = numStack.pop();
                    if (numStack.isEmpty()) {
                        cerr << "Error: Missing operands!" << endl;
                        return 0;
                    }
                    double a = numStack.pop();
                    numStack.push(calculate(topOp, a, b));
                }
                expectOperand = false;
                
                // 继续比较当前运算符与新的栈顶运算符
                continue;
            }
            else {
                cerr << "Error: Invalid expression syntax!" << endl;
                return 0;
            }
        }
    }

    // 检查最终结果
    if (numStack.isEmpty()) {
        cerr << "Error: Empty expression!" << endl;
        return 0;
    }
    
    double result = numStack.pop();
    if (!numStack.isEmpty()) {
        cerr << "Error: Incomplete expression!" << endl;
        return 0;
    }
    
    return result;
}

int main() {
    // 解决中文乱码 - 使用UTF-8编码
    #ifdef _WIN32
    SetConsoleOutputCP(65001);
    #endif

    cout << "Expression Calculator Test:" << endl;
    cout << "===========================" << endl;

    // 简单测试用例
    const char* tests[] = {
        "3+4*2",           // 11
        "(2+3)^2",         // 25  
        "sin(3.1416/2)",   // ~1
        "log(100)",        // 2
        "5!",              // 120
        "3.5 * 2 + 1.5",   // 8.5
        "10 / 2 - 1",      // 4
        "2 + 3 * 4",       // 14
        "(2 + 3) * 4"      // 20
    };
    
    double expected[] = {11, 25, 1, 2, 120, 8.5, 4, 14, 20};
    
    for (int i = 0; i < 9; i++) {
        double result = evaluate(tests[i]);
        cout << tests[i] << " = " << result;
        if (fabs(result - expected[i]) < 0.0001) {
            cout << " ?" << endl;
        } else {
            cout << " ? (expected: " << expected[i] << ")" << endl;
        }
    }

    // 复杂测试用例
    cout << "\nAdvanced Tests:" << endl;
    cout << "===============" << endl;
    
    const char* advTests[] = {
        "2*sin(0.5236) + ln(2.71828)",  // ~2 (2*0.5 + 1)
        "cos(0) + log(10)",             // 2 (1 + 1)
        "3^2 + 4^2"                     // 25
    };
    
    for (int i = 0; i < 3; i++) {
        double result = evaluate(advTests[i]);
        cout << advTests[i] << " = " << result << endl;
    }

    #ifdef _WIN32
    system("pause");
    #endif
    return 0;
}


任务3
#include <iostream>
#include <cstring>
#include <cmath>
#include <cctype>
#include <stack>
#include <string>
#include <map>
#include <stdexcept>
#include <cstdlib>
using namespace std;

class ExpressionCalculator {
private:
    enum Operator { ADD, SUB, MUL, DIV, POW, FACT, L_PAREN, R_PAREN, END, SIN, COS, TAN, LOG, LN };
    
    map<Operator, int> precedence;
    
    void initPrecedence() {
        precedence[SIN] = precedence[COS] = precedence[TAN] = precedence[LOG] = precedence[LN] = 5;
        precedence[POW] = 4;
        precedence[FACT] = 3;
        precedence[MUL] = precedence[DIV] = 2;
        precedence[ADD] = precedence[SUB] = 1;
        precedence[L_PAREN] = precedence[R_PAREN] = precedence[END] = 0;
    }
    
    void skipSpaces(const string& expr, int& index) {
        while (index < expr.length() && expr[index] == ' ') index++;
    }
    
    double readNumber(const string& expr, int& index) {
        double number = 0.0;
        bool hasDecimal = false;
        double decimalFactor = 0.1;
        
        while (index < expr.length() && isdigit(expr[index])) {
            number = number * 10 + (expr[index] - '0');
            index++;
        }
        
        if (index < expr.length() && expr[index] == '.') {
            index++;
            while (index < expr.length() && isdigit(expr[index])) {
                number += (expr[index] - '0') * decimalFactor;
                decimalFactor *= 0.1;
                index++;
            }
        }
        
        return number;
    }
    
    Operator readOperator(const string& expr, int& index) {
        skipSpaces(expr, index);
        if (index >= expr.length()) return END;
        
        char c = expr[index];
        switch (c) {
            case '+': index++; return ADD;
            case '-': index++; return SUB;
            case '*': index++; return MUL;
            case '/': index++; return DIV;
            case '^': index++; return POW;
            case '!': index++; return FACT;
            case '(': index++; return L_PAREN;
            case ')': index++; return R_PAREN;
        }
        
        if (index + 2 < expr.length()) {
            string substr = expr.substr(index, 3);
            if (substr == "sin" || substr == "SIN") { index += 3; return SIN; }
            if (substr == "cos" || substr == "COS") { index += 3; return COS; }
            if (substr == "tan" || substr == "TAN") { index += 3; return TAN; }
            if (substr == "log" || substr == "LOG") { index += 3; return LOG; }
        }
        
        if (index + 1 < expr.length()) {
            string substr = expr.substr(index, 2);
            if (substr == "ln" || substr == "LN") { index += 2; return LN; }
        }
        
        return END;
    }
    
    double calculate(Operator op, double a, double b = 0) {
        switch (op) {
            case ADD: return a + b;
            case SUB: return a - b;
            case MUL: return a * b;
            case DIV: 
                if (b == 0) throw runtime_error("Division by zero");
                return a / b;
            case POW: return pow(a, b);
            case FACT: {
                int n = static_cast<int>(a);
                if (n < 0 || a != n) throw runtime_error("Factorial requires non-negative integer");
                double result = 1;
                for (int i = 2; i <= n; i++) result *= i;
                return result;
            }
            case SIN: return sin(a);
            case COS: return cos(a);
            case TAN: return tan(a);
            case LOG: 
                if (a <= 0) throw runtime_error("Logarithm requires positive argument");
                return log10(a);
            case LN: 
                if (a <= 0) throw runtime_error("Natural logarithm requires positive argument");
                return log(a);
            default: return 0;
        }
    }
    
    void processOperator(stack<double>& numbers, stack<Operator>& operators) {
        Operator op = operators.top();
        operators.pop();
        
        if (op == SIN || op == COS || op == TAN || op == LOG || op == LN) {
            if (numbers.empty()) throw runtime_error("Missing operand for function");
            double a = numbers.top(); numbers.pop();
            numbers.push(calculate(op, a));
        } else if (op == FACT) {
            if (numbers.empty()) throw runtime_error("Missing operand for factorial");
            double a = numbers.top(); numbers.pop();
            numbers.push(calculate(op, a));
        } else {
            if (numbers.size() < 2) throw runtime_error("Missing operands");
            double b = numbers.top(); numbers.pop();
            double a = numbers.top(); numbers.pop();
            numbers.push(calculate(op, a, b));
        }
    }

public:
    ExpressionCalculator() { initPrecedence(); }
    
    double evaluate(const string& expression) {
        stack<double> numbers;
        stack<Operator> operators;
        int index = 0;
        bool expectOperand = true;
        
        while (index <= expression.length()) {
            skipSpaces(expression, index);
            
            if (index >= expression.length()) {
                while (!operators.empty()) processOperator(numbers, operators);
                break;
            }
            
            char c = expression[index];
            
            if (isdigit(c) || c == '.') {
                if (!expectOperand) throw runtime_error("Unexpected number");
                numbers.push(readNumber(expression, index));
                expectOperand = false;
            } else {
                Operator op = readOperator(expression, index);
                
                if (op == END) throw runtime_error("Unrecognized character");
                
                if (expectOperand) {
                    if (op == SUB) {
                        numbers.push(0);
                        operators.push(SUB);
                    } else if (op == SIN || op == COS || op == TAN || op == LOG || op == LN) {
                        operators.push(op);
                    } else if (op == L_PAREN) {
                        operators.push(op);
                    } else {
                        throw runtime_error("Unexpected operator");
                    }
                } else {
                    if (op == FACT) {
                        operators.push(op);
                        processOperator(numbers, operators);
                    } else if (op == R_PAREN) {
                        while (!operators.empty() && operators.top() != L_PAREN) {
                            processOperator(numbers, operators);
                        }
                        if (operators.empty()) throw runtime_error("Mismatched parentheses");
                        operators.pop();
                        
                        if (!operators.empty() && 
                            (operators.top() == SIN || operators.top() == COS || 
                             operators.top() == TAN || operators.top() == LOG || operators.top() == LN)) {
                            processOperator(numbers, operators);
                        }
                    } else {
                        while (!operators.empty() && 
                               precedence[operators.top()] >= precedence[op] &&
                               operators.top() != L_PAREN) {
                            processOperator(numbers, operators);
                        }
                        operators.push(op);
                        expectOperand = true;
                    }
                }
            }
        }
        
        if (numbers.size() != 1) throw runtime_error("Invalid expression");
        return numbers.top();
    }
};

int main() {
    #ifdef _WIN32
    system("chcp 65001 > nul");
    #endif
    
    ExpressionCalculator calc;
    string input;
    
    cout << "Expression Calculator" << endl;
    cout << "=====================" << endl;
    cout << "Supported operations: + - * / ^ ! ( )" << endl;
    cout << "Supported functions: sin cos tan log ln" << endl;
    cout << "Examples: 3+4*2, (2+3)^2, sin(3.1416/2), 5!" << endl;
    cout << "Type 'quit' to exit" << endl << endl;
    
    while (true) {
        cout << "Enter expression: ";
        getline(cin, input);
        
        if (input == "quit" || input == "exit") break;
        if (input.empty()) continue;
        
        try {
            double result = calc.evaluate(input);
            cout << "Result: " << result << endl;
        } catch (const exception& e) {
            cout << "Error: " << e.what() << endl;
        }
        
        cout << endl;
    }
    
    return 0;
}



