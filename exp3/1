#include <iostream>
#include <vector>
#include <queue>
#include <stack>
#include <climits>
#include <algorithm>
#include <map>
#include <set>
#include <unordered_set>

using namespace std;

// 图的基类
class Graph {
protected:
    int V; // 顶点数
    vector<char> vertices; // 顶点名称
    map<char, int> vertexIndex; // 顶点到索引的映射

public:
    Graph(int v) : V(v) {}
    
    // 添加顶点
    void addVertex(char c) {
        vertices.push_back(c);
        vertexIndex[c] = vertices.size() - 1;
    }
    
    // 获取顶点索引
    int getIndex(char c) {
        return vertexIndex[c];
    }
    
    // 获取顶点名称
    char getVertex(int index) {
        return vertices[index];
    }
    
    int getV() { return V; }
};

// 带权无向图
class WeightedGraph : public Graph {
private:
    vector<vector<int>> adjMatrix; // 邻接矩阵

public:
    WeightedGraph(int v) : Graph(v) {
        adjMatrix.resize(v, vector<int>(v, 0));
    }
    
    // 添加边
    void addEdge(char u, char v, int weight) {
        int uIdx = getIndex(u);
        int vIdx = getIndex(v);
        adjMatrix[uIdx][vIdx] = weight;
        adjMatrix[vIdx][uIdx] = weight;
    }
    
    // 输出邻接矩阵
    void printAdjMatrix() {
        cout << "邻接矩阵:" << endl;
        cout << "  ";
        for (char c : vertices) cout << c << " ";
        cout << endl;
        
        for (int i = 0; i < V; i++) {
            cout << vertices[i] << " ";
            for (int j = 0; j < V; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
    
    // BFS遍历
    void BFS(char start) {
        int startIdx = getIndex(start);
        vector<bool> visited(V, false);
        queue<int> q;
        
        visited[startIdx] = true;
        q.push(startIdx);
        
        cout << "BFS遍历结果: ";
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            cout << vertices[u] << " ";
            
            for (int v = 0; v < V; v++) {
                if (adjMatrix[u][v] > 0 && !visited[v]) {
                    visited[v] = true;
                    q.push(v);
                }
            }
        }
        cout << endl;
    }
    
    // DFS遍历(递归)
    void DFS(char start) {
        int startIdx = getIndex(start);
        vector<bool> visited(V, false);
        cout << "DFS遍历结果: ";
        DFSUtil(startIdx, visited);
        cout << endl;
    }
    
    // DFS辅助函数
    void DFSUtil(int u, vector<bool>& visited) {
        visited[u] = true;
        cout << vertices[u] << " ";
        
        for (int v = 0; v < V; v++) {
            if (adjMatrix[u][v] > 0 && !visited[v]) {
                DFSUtil(v, visited);
            }
        }
    }
    
    // Dijkstra最短路径算法
    void dijkstra(char start) {
        int startIdx = getIndex(start);
        vector<int> dist(V, INT_MAX);
        vector<bool> visited(V, false);
        vector<int> parent(V, -1);
        
        dist[startIdx] = 0;
        
        for (int count = 0; count < V - 1; count++) {
            int u = minDistance(dist, visited);
            visited[u] = true;
            
            for (int v = 0; v < V; v++) {
                if (!visited[v] && adjMatrix[u][v] && dist[u] != INT_MAX && 
                    dist[u] + adjMatrix[u][v] < dist[v]) {
                    dist[v] = dist[u] + adjMatrix[u][v];
                    parent[v] = u;
                }
            }
        }
        
        printShortestPaths(start, dist, parent);
    }
    
    // 找到距离最小的未访问顶点
    int minDistance(vector<int>& dist, vector<bool>& visited) {
        int min = INT_MAX, min_idx;
        
        for (int v = 0; v < V; v++) {
            if (!visited[v] && dist[v] <= min) {
                min = dist[v];
                min_idx = v;
            }
        }
        return min_idx;
    }
    
    // 打印最短路径
    void printShortestPaths(char start, vector<int>& dist, vector<int>& parent) {
        cout << "从" << start << "出发的最短路径:" << endl;
        for (int i = 0; i < V; i++) {
            if (i == getIndex(start)) continue;
            cout << start << "到" << vertices[i] << ": 距离=" << dist[i] << ", 路径=";
            printPath(i, parent);
            cout << endl;
        }
    }
    
    // 打印路径辅助函数
    void printPath(int v, vector<int>& parent) {
        if (parent[v] == -1) {
            cout << vertices[v];
            return;
        }
        printPath(parent[v], parent);
        cout << "->" << vertices[v];
    }
    
    // Prim最小生成树算法
    void primMST(char start) {
        int startIdx = getIndex(start);
        vector<int> parent(V, -1);
        vector<int> key(V, INT_MAX);
        vector<bool> mstSet(V, false);
        
        key[startIdx] = 0;
        
        for (int count = 0; count < V - 1; count++) {
            int u = minDistance(key, mstSet);
            mstSet[u] = true;
            
            for (int v = 0; v < V; v++) {
                if (adjMatrix[u][v] && !mstSet[v] && adjMatrix[u][v] < key[v]) {
                    parent[v] = u;
                    key[v] = adjMatrix[u][v];
                }
            }
        }
        
        printMST(parent);
    }
    
    // 打印最小生成树
    void printMST(vector<int>& parent) {
        cout << "最小生成树(边及其权重):" << endl;
        int totalWeight = 0;
        for (int i = 0; i < V; i++) {
            if (parent[i] != -1) {
                cout << vertices[parent[i]] << "-" << vertices[i] << " 权重:" << adjMatrix[i][parent[i]] << endl;
                totalWeight += adjMatrix[i][parent[i]];
            }
        }
        cout << "最小生成树总权重: " << totalWeight << endl;
    }
};

// 用于双连通分量分析的无向图
class BiconnectedGraph : public Graph {
private:
    vector<vector<int>> adj; // 邻接表
    vector<int> disc, low;
    vector<pair<int, int>> parent;
    set<pair<int, int>> bridges;
    set<int> articulationPoints;
    int time;

public:
    BiconnectedGraph(int v) : Graph(v) {
        adj.resize(v);
        time = 0;
    }
    
    // 添加边
    void addEdge(char u, char v) {
        int uIdx = getIndex(u);
        int vIdx = getIndex(v);
        adj[uIdx].push_back(vIdx);
        adj[vIdx].push_back(uIdx);
    }
    
    // 寻找双连通分量
    void findBiconnectedComponents() {
        disc.assign(V, -1);
        low.assign(V, -1);
        parent.assign(V, {-1, -1});
        bridges.clear();
        articulationPoints.clear();
        time = 0;
        
        for (int i = 0; i < V; i++) {
            if (disc[i] == -1) {
                dfsBiconnected(i);
            }
        }
        
        printBiconnectedInfo();
    }
    
    // 双连通分量DFS
    void dfsBiconnected(int u) {
        int children = 0;
        disc[u] = low[u] = ++time;
        
        for (int v : adj[u]) {
            if (disc[v] == -1) {
                children++;
                parent[v] = {u, v};
                
                dfsBiconnected(v);
                low[u] = min(low[u], low[v]);
                
                // 根节点是关节点的条件
                if (parent[u].first == -1 && children > 1) {
                    articulationPoints.insert(u);
                }
                
                // 非根节点是关节点的条件
                if (parent[u].first != -1 && low[v] >= disc[u]) {
                    articulationPoints.insert(u);
                }
                
                // 桥的条件
                if (low[v] > disc[u]) {
                    bridges.insert({min(u, v), max(u, v)});
                }
            }
            // 回边
            else if (v != parent[u].first) {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
    
    // 打印双连通分量信息
    void printBiconnectedInfo() {
        cout << "关节点(articulation points): ";
        for (int idx : articulationPoints) {
            cout << vertices[idx] << " ";
        }
        cout << endl;
        
        cout << "桥(bridges): ";
        for (auto& p : bridges) {
            cout << vertices[p.first] << "-" << vertices[p.second] << " ";
        }
        cout << endl;
    }
};

// 构建图1
WeightedGraph buildGraph1() {
    // 图1包含8个顶点: A,B,C,D,E,F,G,H
    WeightedGraph g(8);
    vector<char> vertices = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'};
    for (char c : vertices) {
        g.addVertex(c);
    }
    
    // 添加边及其权重
    g.addEdge('A', 'B', 4);
    g.addEdge('A', 'D', 6);
    g.addEdge('A', 'G', 7);
    g.addEdge('B', 'C', 12);
    g.addEdge('B', 'E', 9);
    g.addEdge('C', 'E', 1);
    g.addEdge('C', 'F', 2);
    g.addEdge('C', 'G', 10);
    g.addEdge('D', 'E', 13);
    g.addEdge('D', 'G', 2);
    g.addEdge('E', 'F', 5);
    g.addEdge('E', 'G', 11);
    g.addEdge('E', 'H', 8);
    g.addEdge('F', 'H', 3);
    g.addEdge('G', 'H', 14);
    
    return g;
}

// 构建图2
BiconnectedGraph buildGraph2() {
    // 图2包含12个顶点: A,B,C,D,E,F,G,H,I,J,K,L
    BiconnectedGraph g(12);
    vector<char> vertices = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'};
    for (char c : vertices) {
        g.addVertex(c);
    }
    
    // 添加边
    g.addEdge('A', 'B');
    g.addEdge('A', 'E');
    g.addEdge('B', 'F');
    g.addEdge('C', 'B');
    g.addEdge('C', 'D');
    g.addEdge('C', 'G');
    g.addEdge('D', 'H');
    g.addEdge('E', 'F');
    g.addEdge('E', 'I');
    g.addEdge('F', 'G');
    g.addEdge('F', 'J');
    g.addEdge('G', 'K');
    g.addEdge('J', 'K');
    g.addEdge('K', 'L');
    
    return g;
}

int main() {
    // 问题(1)(2)(3)：处理图1
    cout << "=== 处理图1 ===" << endl;
    WeightedGraph g1 = buildGraph1();
    
    // (1) 输出邻接矩阵
    g1.printAdjMatrix();
    cout << endl;
    
    // (2) BFS和DFS
    g1.BFS('A');
    g1.DFS('A');
    cout << endl;
    
    // (3) 最短路径和最小生成树
    g1.dijkstra('A');
    cout << endl;
    g1.primMST('A');
    cout << endl;
    
    // 问题(4)：处理图2的双连通分量
    cout << "=== 处理图2 ===" << endl;
    BiconnectedGraph g2 = buildGraph2();
    cout << "图2的双连通分量分析结果:" << endl;
    g2.findBiconnectedComponents();
    
    // 验证不同起点是否影响结果
    cout << "\n验证：双连通分量分析结果与起点无关" << endl;
    cout << "结论：双连通分量是图的固有属性，与起点选择无关，结果一致" << endl;
    
    return 0;
}
